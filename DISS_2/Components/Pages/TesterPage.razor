@page "/"
@using DISS_2.BackEnd
@using DISS_2.BackEnd.Generators
@using DISS_2.BackEnd.Generators.Empiric
@using DISS_2.BackEnd.Generators.Exponential
@using DISS_2.BackEnd.Generators.Triangular
@using DISS_2.BackEnd.Generators.Uniform
@using DISS_2.Components.Basic.Tester
@rendermode InteractiveServer

<h1 class="">Tester</h1>
<div class="container-fluid mb-5">
    <div class="row">
    </div>
    <div class="row">
        <div class="d-flex flex-wrap p-0 m-0 gap-4">
            <!-- Discrete Uniform Generator -->
            <GeneratorCard Headline="Discrete Uniform"
                           Initialize="@(() => InitializeUniformGenerator<int>(MinUniDisc, MaxUniDisc, true))"
                           Generator="MainApp.Instance.TesterGenerators.UniformDiscreteGenerator"
                           CouldBeInitialized="() => { return MinUniDisc < MaxUniDisc; }">
                <label class="mt-3">Min:</label>
                <input class="form-control" type="number" @bind="MinUniDisc" @bind:event="oninput" step="1"/>

                <label class="mt-3">Max:</label>
                <input class="form-control" type="number" @bind="MaxUniDisc" @bind:event="oninput" step="1"/>
            </GeneratorCard>

            <!-- Real Uniform Generator -->
            <GeneratorCard Headline="Real Uniform"
                           Initialize="@(() => InitializeUniformGenerator<double>(MinUniReal, MaxUniReal, false))"
                           Generator="MainApp.Instance.TesterGenerators.UniformRealGenerator"
                           CouldBeInitialized="() => {return MinUniReal < MaxUniReal;}">
                <label class="mt-3">Min:</label>
                <input class="form-control" type="number" @bind="MinUniReal" @bind:event="oninput" step="0.1"/>

                <label class="mt-3">Max:</label>
                <input class="form-control" type="number" @bind="MaxUniReal" @bind:event="oninput" step="0.1"/>
            </GeneratorCard>

            <!-- Discrete Empiric Generator -->
            <GeneratorCard Headline="Discrete Empiric"
                           Initialize="@(() => InitializeEmpiricGenerator(_empiricDiscreteRows, true))"
                           Generator="MainApp.Instance.TesterGenerators.EmpiricDiscreteGenerator"

                           CouldBeInitialized="() => { return true; }">
                <div class="container">
                    @foreach (var row in _empiricDiscreteRows)
                    {
                        <EmpiricDiscreteRow
                            DistrModel="row"
                            OnRemove="@(() => RemoveRow(row, _empiricDiscreteRows))"
                            OnChange="StateHasChanged"
                        />
                    }
                    <div class="row">
                        <button class="btn btn-primary mt-2" @onclick="() => AddRow(_empiricDiscreteRows, true)">
                            Add random distribution
                        </button>
                    </div>
                </div>
            </GeneratorCard>

            <!-- Real Empiric Generator -->
            <GeneratorCard Headline="Real Empiric"
                           Initialize="@(() => InitializeEmpiricGenerator(_empiricRealRows, false))"
                           Generator="MainApp.Instance.TesterGenerators.EmpiricRealGenerator"
                           CouldBeInitialized="() => { return true; }">
                <div class="container">
                    @foreach (var row in _empiricRealRows)
                    {
                        <EmpiricRealRow DistrModel="row" OnRemove="@(() => RemoveRow(row, _empiricRealRows))"/>
                    }
                    <div class="row">
                        <button class="btn btn-primary mt-2" @onclick="() => AddRow(_empiricRealRows, false)">
                            Add random distribution
                        </button>
                    </div>
                </div>
            </GeneratorCard>

            <GeneratorCard Headline="Discrete Triangular"
                           Initialize="@(() => InitializeTriangularIntGenerator(MinTriangularDisc, ModTriangularDisc, MaxTriangularDisc))"
                           Generator="MainApp.Instance.TesterGenerators.TriangularIntGenerator"
                           CouldBeInitialized="() => { return true; }">
                <label class="mt-3">Min:</label>
                <input class="form-control" type="number" @bind="MinTriangularDisc" @bind:event="oninput" step="1"/>

                <label class="mt-3">Mod:</label>
                <input class="form-control" type="number" @bind="ModTriangularDisc" @bind:event="oninput" step="1"/>

                <label class="mt-3">Max:</label>
                <input class="form-control" type="number" @bind="MaxTriangularDisc" @bind:event="oninput" step="1"/>
            </GeneratorCard>

            <GeneratorCard Headline="Real Triangular"
                           Initialize="@(() => InitializeTriangularRealGenerator(MinTriangularReal, ModTriangularReal, MaxTriangularReal))"
                           Generator="MainApp.Instance.TesterGenerators.TriangularRealGenerator"
                           CouldBeInitialized="() => { return true; }">
                <label class="mt-3">Min:</label>
                <input class="form-control" type="number" @bind="MinTriangularReal" @bind:event="oninput" step="0.1"/>

                <label class="mt-3">Mod:</label>
                <input class="form-control" type="number" @bind="ModTriangularReal" @bind:event="oninput" step="0.1"/>

                <label class="mt-3">Max:</label>
                <input class="form-control" type="number" @bind="MaxTriangularReal" @bind:event="oninput" step="0.1"/>
            </GeneratorCard>

            <GeneratorCard Headline="Real Exponential"
                           Initialize="@(() => InitializeExponentialGenerator(Lambda))"
                           Generator="MainApp.Instance.TesterGenerators.ExponentialGenerator"
                           CouldBeInitialized="() => { return true; }">
                <label class="mt-3">Lambda:</label>
                <input class="form-control" type="number" @bind="Lambda" @bind:event="oninput" step="0.1" min="0.0"/>
            </GeneratorCard>
        </div>
    </div>
</div>

@code {
    public int MinUniDisc { get; set; } = 0;
    public int MaxUniDisc { get; set; } = 100;
    public double MinUniReal { get; set; } = 0.0;
    public double MaxUniReal { get; set; } = 1.0;

    private int MinTriangularDisc { get; set; } = 0;
    private int ModTriangularDisc { get; set; } = 25;
    private int MaxTriangularDisc { get; set; } = 50;

    private double MinTriangularReal { get; set; } = 0;
    private double ModTriangularReal { get; set; } = 25;
    private double MaxTriangularReal { get; set; } = 50;

    private double Lambda { get; set; } = 2.0;

    private readonly List<EmpiricDistrModel<double>> _empiricRealRows = new();
    private readonly List<EmpiricDistrModel<int>> _empiricDiscreteRows = new();

    private Generator<T> InitializeUniformGenerator<T>(T min, T max, bool isDiscrete)
    {
        Console.WriteLine("ahoj");
        if (isDiscrete)
        {
            UniformGenerator<int> generator = UniformGeneratorFactory.CreateDiscreteUniformGenerator(Convert.ToInt32(min), Convert.ToInt32(max));
            generator.EnableHistory();
            MainApp.Instance.TesterGenerators.UniformDiscreteGenerator = generator;
            return (generator as Generator<T>)!;
        }
        else
        {
            UniformGenerator<double> generator = UniformGeneratorFactory.CreateRealUniformGenerator(Convert.ToDouble(min), Convert.ToDouble(max));
            generator.EnableHistory();
            MainApp.Instance.TesterGenerators.UniformRealGenerator = generator;
            return (generator as Generator<T>)!;
        }
    }

    private Generator<T> InitializeEmpiricGenerator<T>(List<EmpiricDistrModel<T>> rows, bool isDiscrete)
    {
        var generator = new EmpiricGenerator<T>(rows);
        generator.EnableHistory();

        if (isDiscrete)
        {
            MainApp.Instance.TesterGenerators.EmpiricDiscreteGenerator = generator as EmpiricGenerator<int>;
        }
        else
        {
            MainApp.Instance.TesterGenerators.EmpiricRealGenerator = generator as EmpiricGenerator<double>;
        }

        return generator;
    }

    private void AddRow<T>(List<EmpiricDistrModel<T>> rows, bool isDiscrete)
    {
        if (isDiscrete)
        {
            int newMinimum = 0;
            if (rows.Count >= 1)
            {
                newMinimum = (rows[^1].Generator as UniformGenerator<int>)!.Max;
            }

            rows.Add(
                new EmpiricDistrModel<T>(
                    (UniformGeneratorFactory.CreateDiscreteUniformGenerator(newMinimum, newMinimum + 10) as Generator<T>)!,
                    0.5
                )
            );
        }
        else
        {
            double newMinimum = 0;
            if (rows.Count >= 1)
            {
                newMinimum = (rows[^1].Generator as UniformGenerator<double>)!.Max;
            }

            rows.Add(
                new EmpiricDistrModel<T>(
                    (UniformGeneratorFactory.CreateRealUniformGenerator(newMinimum, newMinimum + 1.0) as Generator<T>)!,
                    0.5
                )
            );
        }
    }

    private void RemoveRow<T>(EmpiricDistrModel<T> row, List<EmpiricDistrModel<T>> rows)
    {
        rows.Remove(row);
    }

    private Generator<int> InitializeTriangularIntGenerator(int min, int mode, int max)
    {
        TriangularIntGenerator gen = new TriangularIntGenerator(
            min, mode, max
        );
        gen.EnableHistory();
        MainApp.Instance.TesterGenerators.TriangularIntGenerator = gen;
        return gen;
    }

    private Generator<double> InitializeTriangularRealGenerator(double min, double mode, double max)
    {
        TriangularRealGenerator gen = new TriangularRealGenerator(
            min, mode, max
        );
        gen.EnableHistory();
        MainApp.Instance.TesterGenerators.TriangularRealGenerator = gen;
        return gen;
    }

    private Generator<double> InitializeExponentialGenerator(double lambda)
    {
        ExponentialGenerator gen = new ExponentialGenerator(lambda);
        gen.EnableHistory();
        MainApp.Instance.TesterGenerators.ExponentialGenerator = gen;
        return gen;
    }

}
